<h1 id="use-claude-crc-dont-lose-features-to-generous-inference">Use
claude-crc, Donâ€™t Lose Features to â€˜Generousâ€™ Inference</h1>
<h2 id="level-spec-driven-development-for-claude"><em>3-Level
Spec-Driven Development For Claude</em></h2>
<h2 id="the-problem-with-2-level-spec-driven-development">The Problem
With 2-Level Spec-Driven Development</h2>
<p>2-level spec driven development suffers from the same problem as vibe
coding â€“ it just takes longer. Which means it bites you after you done a
lot more work. I did some hand-rolled, 2-level spec-driven development
for an app Iâ€™ve been building. By 2-level, I mean you have a collection
of spec documents and tell Claude to generate code from it. When you
change one set, you tell Claude to check your changes and update the
other. It works pretty well as a light-weight alternative to vibe
coding. But itâ€™s not a tiny app and I after a while I ran into
problems.</p>
<p>Claude â€œgenerouslyâ€ inferred things from my specs that werenâ€™t
actually in there. I wasnâ€™t as diligent as I should have been with
reviewing the generated code â€“ because AI, I suppose. It generates so
much code so fast that eventually it becomes easier just to have it
auto-approve already. Claude can give you a lot more than you asked for.
Itâ€™s great! But then I changed a spec, Claude changed code in response
to that, and it decided to remove one of the generous additions I hadnâ€™t
asked for. Only I had come to think of that as part of my app.</p>
<h2 id="the-solution-3-level-development">The Solution: 3-Level
Development</h2>
<p>What I wanted was a middle level where I could see how Claude was
interpreting my specs but that wasnâ€™t reams and reams of code. I looked
at some spec-driven development packages and read <a
href="https://arxiv.org/abs/2508.14511">What You See Is What It Does
paper</a>, by Meng and Jackson at MIT. Itâ€™s a good paper with clear
benefits but I didnâ€™t like their â€œdumb dataâ€ / â€œprocedural database
codeâ€ model. Eventually, I realized that I had actually used a system
kind of like theirs for decades but for human development, not Claude
development.</p>
<p>From the late 80s through the early 2000s, I used <a
href="https://en.wikipedia.org/wiki/Class-responsibility-collaboration_card">CRC
cards</a>, sequence diagrams, and UI mockups to communicate with
customers in order to verify that we were on the same page and actually
understood what they really wanted. Customers are notoriously bad at
telling developers what they want.</p>
<p>I realized with Claude as the developer I am now the customer. ğŸ˜®</p>
<p>OK, maybe itâ€™s not the same thing. As the lead developer on this
project I want to know what Claude is going to do and why. Of course
this is a bit of a fantasy given how LLMs work, but theyâ€™re great at
following plans. This is a way to ask Claude to make a plan thatâ€™s easy
to examine and that makes a ton of sense for developing software.</p>
<h3 id="before-and-after">Before And After</h3>
<p>I developed a game app with a 2-level process. The game is quite
elaborate, it combines multiuser role playing with dynamic world
building and peer-to-peer networking. Claude put a back button on one of
my pages and after some spec changes, the button disappeared. I hadnâ€™t
requested the button but I had come to rely on it during my testing.</p>
<p>The 3-level process eliminates problems like these because Claude
makes <strong>easy to read</strong> designs reflecting my specs. This
lets me easily see where the buttons are without having to run the app
or pore through reams of HTML templates. And I can rest assured that the
buttons in the designs will come through in the implementation. The
automatic gap analysis points out where elements of the design differ
from the specs and even lays out potential oversights like global error
handling, security, and so on.</p>
<h2 id="humans-doing-crc-spec-driven-development">Humans Doing CRC
Spec-Driven Development</h2>
<p>CRC cards, sequence diagrams, and UI mockups are great ways to talk
to customers because they form a super high level design document that
captures the spec and determines the implementation but despite that
power, theyâ€™re concise, theyâ€™re visual, and theyâ€™re not algorithmic.
That means theyâ€™re also great for communicating between customers and
developers, i.e.Â me and Claude. They appear to be OO (object oriented)
but theyâ€™re actually not. Theyâ€™re really about ADTs (abstract data
types); a concept that predates OO and permeates programming of all
sorts â€“ basically itâ€™s just a collection of state and a set of
operations on it. So they can really apply to any project, not just
object oriented ones.</p>
<h2
id="the-crc-design-agent-for-claude-providing-a-lightweght-complete-software-process">The
CRC Design Agent For Claude: Providing A Lightweght, Complete Software
Process</h2>
<p>The idea is to make a lightweight but complete software process for
Claude that gives people a way to see how the LLM interprets the
requirements so they can clarify their specifications when the LLM
infers things that shouldnâ€™t be there or interprets things in ways in
which you do not expect. Thereâ€™s another motivation for this process as
well: maintainability. Itâ€™d be nice if you could be confident that when
you make changes to your requirements, the changes will ripple safely
down to the code.</p>
<p>Requirements, and design specification documents are key parts of the
software process but projects also have code, tests, and documentation.
This is all linked back to the specs the human writes (the
â€œrequirementsâ€) through the specs Claude writes (CRC cards, sequence
diagrams, UI layouts and information). This linkage supports
â€œtraceabilityâ€ so that if you change something, you can also update the
things itâ€™s linked to. Claude is great for this, of course, so you can
tell it, â€œI just changed <code>specs/person.md</code>, upate the
associated design specs and code.</p>
<p>CRC cards, sequence diagrams, and UI layouts (both in ASCII art) are
generally written by Claude but people can also write and/or edit them
and then say, â€œI just changed <code>design/crc-Person.md</code>, upate
the associated code and specsâ€.</p>
<p>So traceability allows Claude to propagate changes bi-directionally.
It also makes it easier and safer to refactor code, requirements, and
systems.</p>
<p>The process also provides valuable gap analysis to show you how your
specs, the design specs, and the implementation diverge and what you
might have left out from your specs.</p>
<h2 id="what-it-is">What It Is</h2>
<p>Itâ€™s a collection of skills, commands, and agents for Claude that
assist you in spec-driven development with a CRC process. You can load
it into a fresh project or you can â€œpatch itâ€ into an existing project
and ask Claude to reverse-engineer design and spec docs.</p>
<p>It will make entries in your projectâ€™s <code>.claude/commands</code>,
<code>.claude/skills</code>, <code>.claude/scripts</code>,
<code>.claude/agents</code>, and <code>.claude/docs</code> and it will
add some things to your projectâ€™s CLAUDE.md file. It relies on two
top-level directories: <code>specs</code> and <code>design</code>.</p>
<h2 id="reverse-engineering">Reverse Engineering</h2>
<p>You can use this toolkit to reverse engineer design and specs for an
existing project â€“ the documentation in the .claude directory provides
enough context for that. Try telling Claude, â€œcheck .claude/docs and
agents for context and reverse-engineer a design directory for this
projectâ€.</p>
<p>You can try this out with the example contacts app in the projectâ€™s
<code>expected-result</code> directory by copying it into a fresh
project and removing the <code>specs</code>, <code>design</code>, and
<code>docs</code> directories. Then initialize the crc tooling and tell
claude to make them itself.</p>
<h2 id="actually-using-it">Actually Using It</h2>
<p>There are three steps to this process and the result will be a fully
linked set of levels:</p>
<ul>
<li>Level 1: general specification / requirements</li>
<li>Level 2: the design and test designs</li>
<li>Level 3: code and docs</li>
</ul>
<p>The files in layers 2 and 3 will contain comments linking them back
to the layers above them and the design directory will contain
traceability files that link layers 1 and 2 to the layers below
them.</p>
<h3 id="installing-it-in-your-claude-project">Installing It In Your
Claude Project</h3>
<ol type="1">
<li>Change directory into your Claude project (i.e.Â a directory that
contains a .claude subdirectory).</li>
<li>If you donâ€™t have it, grab the <a
href="https://github.com/zot/claude-crc/releases">latest release</a> if
needed.</li>
<li>Run the init script</li>
</ol>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Download</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ex">curl</span> <span class="at">-O</span> https://github.com/zot/claude-crc/releases/latest/download/claude-crc-dist.py</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Run</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ex">python3</span> claude-crc-dist.py</span></code></pre></div>
<p>This initializes your project. Donâ€™t worry about overwriting things â€“
it will refuse to run if you have conflicting files in your .claude
directory.</p>
<p>Documentation: see the <a
href="https://github.com/zot/claude-crc">project readme</a>.</p>
<h3 id="step-1-general-specification-requirements">Step 1: General
Specification / Requirements</h3>
<p>A great way to start out is to ask Claude for help like, â€œI want to
make a contact management app. Put specs for it into the top-level specs
directory that I can use with the designer agent.â€ Claude will generate
specs for you. Take look at those and if anything is missing like,
maybe, storage, you can add it yourself or you can ask Claude to add
that to the specs.</p>
<h3 id="step-2-the-design-and-test-designs">Step 2: the Design and Test
Designs</h3>
<p>When youâ€™re pretty happy with the specs ask claude, â€œgenerate designs
and test designsâ€. Claude will delegate that to its
<code>designer</code> subagent and you can examine the designs Claude
comes up with â€“ the UI layouts, sequence diagrams, CRC cards, and test
designs. From examination you might find that your specs need more
fleshing out (you can ask Claude to do that, of course). You might find
that Claude interpreted your specs in unexpected ways â€“ ask Claude to
explain, then correct it and tell it to update your specs so it doesnâ€™t
happen again.</p>
<h3 id="step-3-code-and-docs">Step 3: Code and Docs</h3>
<p>When youâ€™re pretty happy with the design, ask claude, â€œgenerate code,
tests, and docsâ€ and it will populate the source code directories and
the docs directory.</p>
<h3 id="testing-and-fixing-your-app">Testing and Fixing Your App</h3>
<p>Your app might (will probably) not work as soon as Claude generates
it. There might (will probably) be a few things here and there that use
the wrong directory, donâ€™t import something they need, and so on. Even
after the tests run. Youâ€™ll need to try it out and go through a test/fix
loop. Youâ€™ll probably benefit from using the Serena MCP and, if your UI
is a web app, the Playwright MCP â€“ using these is well documented on the
web.</p>
<h2 id="the-result-transformative-claude-development">The Result:
Transformative Claude Development</h2>
<p>Maybe youâ€™ve been vibe coding, 2-level spec coding, or using a
spec-driven process that doesnâ€™t provide an easy-to-read middle layer,
traceability, gap analysis, or doesnâ€™t support continued development
very well. If so, give claude-crc a try and see how it works. Youâ€™ll get
a project that you can change along the way without gaining weird
features you didnâ€™t want and without losing ones you found out you
wanted but didnâ€™t actually ask for.</p>
<ul>
<li><strong>Readable designs</strong> CRC cards show Claudeâ€™s
interpretation before code</li>
<li><strong>Traceability</strong> Every file links back to
requirements</li>
<li><strong>Gap analysis</strong> Automatic detection of
spec/design/code drift</li>
<li><strong>Bidirectional updates</strong> Change specs, design, or code
and propagate</li>
</ul>
<!-- end of list -->
<ul>
<li><strong>Get Started:</strong> <a
href="https://github.com/zot/claude-crc/releases/latest">Download
v1.0.0</a></li>
<li><strong>Documentation:</strong> <a
href="https://github.com/zot/claude-crc">GitHub</a></li>
<li><strong>Questions?</strong> <a
href="https://github.com/zot/claude-crc/issues">Open an Issue</a></li>
</ul>
<!-- end of list -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Chatroom Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: #2c3e50;
            color: white;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        header .header-left {
            flex: 1;
        }

        header h1 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }

        #peer-id {
            font-size: 0.875rem;
            opacity: 0.8;
            font-family: monospace;
        }

        .header-buttons {
            display: flex;
            gap: 0.5rem;
        }

        #browse-files-btn, #contacts-btn {
            padding: 0.5rem 1rem;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background 0.2s;
        }

        #browse-files-btn {
            background: #16a085;
        }

        #browse-files-btn:hover {
            background: #138d75;
        }

        #contacts-btn {
            background: #9b59b6;
        }

        #contacts-btn:hover {
            background: #8e44ad;
        }

        #browse-files-btn:disabled, #contacts-btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }

        .status {
            padding: 0.5rem;
            text-align: center;
            font-size: 0.875rem;
        }

        .status.connecting {
            background: #f39c12;
            color: white;
        }

        .status.connected {
            background: #27ae60;
            color: white;
        }

        .status.error {
            background: #e74c3c;
            color: white;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }

        .status.connecting::before {
            content: "âŸ³ ";
            display: inline-block;
            animation: spin 1s linear infinite;
        }

        #mode-indicator {
            background: #34495e;
            color: white;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            font-weight: 500;
        }

        main {
            flex: 1;
            display: flex;
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
            overflow: hidden;
        }

        #chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            overflow: hidden;
        }

        #messages {
            flex: 1;
            background: white;
            border-radius: 8px;
            padding: 1rem;
            overflow-y: auto;
            margin-bottom: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 4px;
            background: #ecf0f1;
        }

        .message.own {
            background: #3498db;
            color: white;
            margin-left: 2rem;
        }

        .message.other {
            background: #ecf0f1;
            margin-right: 2rem;
        }

        .message.system {
            background: #95a5a6;
            color: white;
            text-align: center;
            font-size: 0.875rem;
            padding: 0.5rem;
        }

        .message .peer {
            font-size: 0.75rem;
            opacity: 0.7;
            margin-bottom: 0.25rem;
            font-family: monospace;
        }

        .message .text {
            word-wrap: break-word;
        }

        .message .time {
            font-size: 0.75rem;
            opacity: 0.6;
            margin-top: 0.25rem;
        }

        #input-area {
            display: flex;
            gap: 0.5rem;
        }

        #message-input {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        button {
            padding: 0.75rem 1.5rem;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.2s;
        }

        button:hover {
            background: #2980b9;
        }

        button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }

        #peer-list-area {
            width: 250px;
            background: white;
            border-left: 1px solid #ddd;
            display: flex;
            flex-direction: column;
        }

        #peer-list-header {
            padding: 1rem;
            background: #ecf0f1;
            border-bottom: 1px solid #ddd;
            font-weight: 600;
        }

        #peer-list {
            flex: 1;
            overflow-y: auto;
        }

        .peer-item {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #ecf0f1;
            cursor: pointer;
            transition: background 0.2s;
        }

        .peer-item:hover {
            background: #f8f9fa;
        }

        .peer-item.active {
            background: #3498db;
            color: white;
        }

        .peer-item.room {
            font-weight: 600;
            background: #ecf0f1;
        }

        .peer-item.room.active {
            background: #2c3e50;
            color: white;
        }

        .peer-item .peer-name {
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
        }

        .peer-item .peer-id {
            font-size: 0.75rem;
            opacity: 0.6;
            font-family: monospace;
        }

        .peer-item.active .peer-id {
            opacity: 0.8;
        }

        .peer-item .unread-badge {
            display: inline-block;
            background: #e74c3c;
            color: white;
            font-size: 0.7rem;
            font-weight: 600;
            padding: 0.15rem 0.4rem;
            border-radius: 10px;
            margin-left: 0.5rem;
            min-width: 1.2rem;
            text-align: center;
        }

        .peer-item.active .unread-badge {
            background: #c0392b;
        }

        /* Peer status indicators */
        .peer-item .peer-header {
            display: flex;
            align-items: center;
        }

        .peer-item .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .peer-item .status-dot.connected {
            background: #4CAF50;
        }

        .peer-item .status-dot.partial {
            background: #FFC107;
        }

        .peer-item .status-dot.offline {
            background: #9E9E9E;
        }

        .peer-item.active .status-dot.connected {
            background: #81C784;
        }

        .peer-item.active .status-dot.partial {
            background: #FFD54F;
        }

        .peer-item.active .status-dot.offline {
            background: #BDBDBD;
        }

        /* File Browser Modal */
        #file-browser-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        #file-browser-modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .modal-header {
            background: #2c3e50;
            color: white;
            padding: 1rem;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.25rem;
        }

        .modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .modal-toolbar {
            padding: 1rem;
            border-bottom: 1px solid #ddd;
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .modal-toolbar select {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.875rem;
        }

        .modal-toolbar button {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
        }

        .file-tree-container {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .file-tree-item {

        }

        .file-tree-item-header {
            padding: 0.5rem;
            margin: 0.25rem 0;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: background 0.2s;
        }

        .file-tree-item-header:hover {
            background: #f8f9fa;
        }

        .file-tree-item.directory > .file-tree-item-header {
            font-weight: 500;
        }

        .file-tree-item.selected > .file-tree-item-header {
            background: #e3f2fd;
            border-left: 3px solid #2196f3;
        }

        .file-tree-item-header .icon {
            width: 20px;
            text-align: center;
        }

        .file-tree-item-header .expand-icon {
            width: 16px;
            cursor: pointer;
            user-select: none;
        }

        .file-tree-item-header .name {
            flex: 1;
        }

        .file-tree-item-header .cid {
            font-size: 0.75rem;
            font-family: monospace;
            opacity: 0.6;
        }

        .file-tree-item-header .actions {
            display: flex;
            gap: 0.25rem;
        }

        .file-tree-item-header .action-btn {
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            background: #3498db;
        }

        .file-tree-item-header .action-btn:hover {
            background: #2980b9;
        }

        .file-tree-item-header .delete-btn {
            background: #e74c3c;
        }

        .file-tree-item-header .delete-btn:hover {
            background: #c0392b;
        }

        .file-tree-item-header .action-btn.downloading {
            background: #95a5a6;
            cursor: wait;
        }

        .file-tree-item-header .action-btn.downloading::before {
            content: "âŸ³ ";
            display: inline-block;
            animation: spin 1s linear infinite;
        }

        .file-tree-children {
            margin-left: 1.5rem;
        }

        .file-tree-item.collapsed .file-tree-item-header + .file-tree-children {
            display: none;
        }

        #drop-zone {
            border: 2px dashed #ddd;
            border-radius: 4px;
            padding: 2rem;
            text-align: center;
            margin-bottom: 1rem;
            color: #999;
        }

        #drop-zone.drag-over {
            border-color: #3498db;
            background: #ecf0f1;
            color: #3498db;
        }

        .hidden {
            display: none !important;
        }

        /* Contacts Modal */
        /* Spec: main.md (demo contact list) */
        #contacts-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        #contacts-modal.active {
            display: flex;
        }

        .contacts-content {
            background: white;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .contacts-list-container {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            min-height: 200px;
        }

        .contact-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: #f8f9fa;
            border-radius: 4px;
            border-left: 3px solid #9b59b6;
        }

        .contact-item .peer-id {
            font-family: monospace;
            font-size: 0.875rem;
            flex: 1;
            word-break: break-all;
        }

        .contact-item .remove-btn {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            font-size: 0.875rem;
            margin-left: 0.5rem;
        }

        .contact-item .remove-btn:hover {
            background: #c0392b;
        }

        .empty-contacts {
            text-align: center;
            padding: 2rem;
            color: #999;
            font-style: italic;
        }

        .add-contact-form {
            padding: 1rem;
            border-top: 1px solid #ddd;
            border-bottom: 1px solid #ddd;
            display: flex;
            gap: 0.5rem;
        }

        .add-contact-form input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.875rem;
            font-family: monospace;
        }

        .add-contact-form button {
            padding: 0.5rem 1rem;
            background: #9b59b6;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
        }

        .add-contact-form button:hover {
            background: #8e44ad;
        }

        .add-contact-form button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }

        .modal-actions {
            padding: 1rem;
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }

        .modal-actions button {
            padding: 0.5rem 1.5rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
        }

        .modal-actions .cancel-btn {
            background: #95a5a6;
            color: white;
        }

        .modal-actions .cancel-btn:hover {
            background: #7f8c8d;
        }

        .modal-actions .accept-btn {
            background: #27ae60;
            color: white;
        }

        .modal-actions .accept-btn:hover {
            background: #229954;
        }
    </style>
</head>
<body>
    <header>
        <div class="header-left">
            <h1>P2P Chatroom Demo</h1>
            <div id="peer-id">Connecting...</div>
        </div>
        <div class="header-buttons">
            <button id="contacts-btn" disabled>Contacts</button>
            <button id="browse-files-btn" disabled>Browse My Files</button>
        </div>
    </header>

    <div id="status" class="status connecting">Connecting to server...</div>
    <div id="mode-indicator">Chat room</div>

    <main>
        <div id="chat-area">
            <div id="messages"></div>
            <div id="input-area">
                <input type="text" id="message-input" placeholder="Type a message..." disabled>
                <button id="send-button" disabled>Send</button>
            </div>
        </div>

        <div id="peer-list-area">
            <div id="peer-list-header">Peers</div>
            <div id="peer-list">
                <div class="peer-item room active" data-peer-id="room">
                    <div class="peer-name">Chat room</div>
                </div>
            </div>
        </div>
    </main>

    <!-- File Browser Modal -->
    <div id="file-browser-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>File Browser</h2>
                <button class="modal-close" id="modal-close-btn">&times;</button>
            </div>
            <div class="modal-toolbar">
                <select id="peer-selector">
                    <option value="me">My Files</option>
                </select>
                <button id="upload-file-btn">Upload File</button>
                <button id="create-dir-btn">New Folder</button>
            </div>
            <div id="selected-folder-indicator" style="padding: 0.5rem 1rem; background: #e3f2fd; border-bottom: 1px solid #ddd; font-size: 0.875rem; display: none;">
                <strong>Upload target:</strong> <span id="selected-folder-path">/</span>
            </div>
            <div class="file-tree-container">
                <div id="drop-zone" class="hidden">
                    Drop files here to upload
                </div>
                <div id="file-tree"></div>
            </div>
            <input type="file" id="file-input" class="hidden" multiple>
        </div>
    </div>

    <!-- Contacts Modal -->
    <!-- Spec: main.md (demo contact list) -->
    <div id="contacts-modal">
        <div class="contacts-content">
            <div class="modal-header">
                <h2>Contact List</h2>
                <button class="modal-close" id="contacts-close-btn">&times;</button>
            </div>
            <div class="add-contact-form">
                <input type="text" id="contact-input" placeholder="Enter peer ID (e.g., 12D3KooW...)" />
                <button id="add-contact-btn">Add</button>
            </div>
            <div class="contacts-list-container">
                <div id="contacts-list"></div>
            </div>
            <div class="modal-actions">
                <button class="cancel-btn" id="contacts-cancel-btn">Cancel</button>
                <button class="accept-btn" id="contacts-accept-btn">Accept</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Import the connect function from the built library
        import { connect } from './index.js';

        // Application - client will be initialized in the async init function
        let client;
        const messagesDiv = document.getElementById('messages');
        const statusDiv = document.getElementById('status');
        const peerIDDiv = document.getElementById('peer-id');
        const modeIndicator = document.getElementById('mode-indicator');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const peerList = document.getElementById('peer-list');

        const ROOM_TOPIC = 'chatroom';
        const PROTOCOL = '/chat/1.0.0';

        let currentMode = 'room'; // 'room' or 'dm'
        let currentPeerID = null;
        let peers = new Map(); // peerID -> { name, inTopic, isContact, directConnected }
        let dmMessages = new Map(); // peerID -> [{text, isOwn, timestamp}]
        let roomMessages = []; // Store room messages: [{senderPeerID, text, isOwn, timestamp}]
        let unreadCounts = new Map(); // peerID -> number of unread messages
        let roomUnreadCount = 0; // Unread messages in room chat
        let pingCheckInterval = null; // Interval for periodic ping checks

        // File browser state
        const fileBrowserModal = document.getElementById('file-browser-modal');
        const browseFilesBtn = document.getElementById('browse-files-btn');
        const modalCloseBtn = document.getElementById('modal-close-btn');

        // Contacts state
        // Spec: main.md (demo contact list)
        const contactsModal = document.getElementById('contacts-modal');
        const contactsBtn = document.getElementById('contacts-btn');
        const contactsCloseBtn = document.getElementById('contacts-close-btn');
        const contactsList = document.getElementById('contacts-list');
        const contactInput = document.getElementById('contact-input');
        const addContactBtn = document.getElementById('add-contact-btn');
        const contactsCancelBtn = document.getElementById('contacts-cancel-btn');
        const contactsAcceptBtn = document.getElementById('contacts-accept-btn');
        let currentContacts = new Set(); // Session-only contact list (not persisted)
        let modalContacts = new Set(); // Working copy for modal editing
        const peerSelector = document.getElementById('peer-selector');
        const fileTreeDiv = document.getElementById('file-tree');
        const uploadFileBtn = document.getElementById('upload-file-btn');
        const createDirBtn = document.getElementById('create-dir-btn');
        const fileInput = document.getElementById('file-input');
        const dropZone = document.getElementById('drop-zone');
        const selectedFolderIndicator = document.getElementById('selected-folder-indicator');
        const selectedFolderPath = document.getElementById('selected-folder-path');

        let currentFilePeerID = null; // Peer whose files we're viewing
        let currentFileEntries = {}; // Current file tree entries
        let expandedDirs = new Set(); // Track expanded directories

        // Encapsulated folder selection with logging
        let _selectedFolder = ''; // Currently selected folder path ('' = root)
        let selectedFolder = {
            get: () => _selectedFolder,
            set: (value) => {
                //console.log(`[FOLDER SELECTION] "${_selectedFolder}" -> "${value}"`);
                _selectedFolder = value;
            }
        };

        function storeRoomMessage(senderPeerID, text, isOwn) {
            roomMessages.push({
                senderPeerID,
                text,
                isOwn,
                timestamp: new Date()
            });
        }

        function storeDMMessage(peerID, text, isOwn) {
            if (!dmMessages.has(peerID)) {
                dmMessages.set(peerID, []);
            }
            dmMessages.get(peerID).push({
                text,
                isOwn,
                timestamp: new Date()
            });
        }

        function addMessage(peerID, text, isOwn, isSystem = false, skipStorage = false) {
            // Store DM messages for later retrieval (but not when displaying from storage)
            if (!isSystem && !skipStorage && currentMode === 'dm' && peerID) {
                storeDMMessage(currentPeerID, text, isOwn);
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isSystem ? 'system' : isOwn ? 'own' : 'other'}`;

            if (!isSystem) {
                const peerDiv = document.createElement('div');
                peerDiv.className = 'peer';
                peerDiv.textContent = isOwn ? 'You' : `Peer: ...${peerID.slice(-8)}`;
                messageDiv.appendChild(peerDiv);
            }

            const textDiv = document.createElement('div');
            textDiv.className = 'text';
            textDiv.textContent = text;
            messageDiv.appendChild(textDiv);

            if (!isSystem) {
                const timeDiv = document.createElement('div');
                timeDiv.className = 'time';
                timeDiv.textContent = new Date().toLocaleTimeString();
                messageDiv.appendChild(timeDiv);
            }

            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function setStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
        }

        function updateMode(mode, targetPeerID = null) {
            currentMode = mode;
            currentPeerID = targetPeerID;

            if (mode === 'room') {
                modeIndicator.textContent = 'Chat room';
                browseFilesBtn.textContent = 'Browse My Files';
            } else {
                modeIndicator.textContent = `Direct message: ...${targetPeerID.slice(-8)}`;
                browseFilesBtn.textContent = 'Browse Peer\'s Files';
            }

            // Update active state in peer list
            document.querySelectorAll('.peer-item').forEach(item => {
                item.classList.remove('active');
            });
            const activeItem = mode === 'room'
                ? document.querySelector('.peer-item.room')
                : document.querySelector(`[data-peer-id="${targetPeerID}"]`);
            if (activeItem) {
                activeItem.classList.add('active');
            }

            messagesDiv.innerHTML = '';
            if (mode === 'room') {
                clearRoomUnreadCount();
                addMessage('', 'Switched to room chat', false, true);
                displayStoredRoomMessages();
            } else {
                addMessage('', `Direct messaging with ...${targetPeerID.slice(-8)}`, false, true);
            }
        }

        function updateUnreadBadge(peerID) {
            const peerItem = document.querySelector(`[data-peer-id="${peerID}"]`);
            if (!peerItem || peerItem.classList.contains('room')) return;

            const count = unreadCounts.get(peerID) || 0;
            let badge = peerItem.querySelector('.unread-badge');

            if (count > 0) {
                if (!badge) {
                    badge = document.createElement('span');
                    badge.className = 'unread-badge';
                    const nameDiv = peerItem.querySelector('.peer-name');
                    nameDiv.appendChild(badge);
                }
                badge.textContent = count;
            } else {
                if (badge) {
                    badge.remove();
                }
            }
        }

        function incrementUnreadCount(peerID) {
            const current = unreadCounts.get(peerID) || 0;
            unreadCounts.set(peerID, current + 1);
            updateUnreadBadge(peerID);
        }

        function clearUnreadCount(peerID) {
            unreadCounts.set(peerID, 0);
            updateUnreadBadge(peerID);
        }

        function updateRoomUnreadBadge() {
            const roomItem = document.querySelector('.peer-item.room');
            if (!roomItem) return;

            let badge = roomItem.querySelector('.unread-badge');

            if (roomUnreadCount > 0) {
                if (!badge) {
                    badge = document.createElement('span');
                    badge.className = 'unread-badge';
                    const nameDiv = roomItem.querySelector('.peer-name');
                    nameDiv.appendChild(badge);
                }
                badge.textContent = roomUnreadCount;
            } else {
                if (badge) {
                    badge.remove();
                }
            }
        }

        function incrementRoomUnreadCount() {
            roomUnreadCount++;
            updateRoomUnreadBadge();
        }

        function clearRoomUnreadCount() {
            roomUnreadCount = 0;
            updateRoomUnreadBadge();
        }

        // Note: Ping-based connection check removed - waitForAck only confirms local
        // server processed the request, not that the remote peer received it.
        // Contacts show as offline (gray) until they join the topic (green).

        // Placeholder for future ping-pong protocol implementation
        async function refreshContactConnections() {
            // Currently no-op since we can't reliably ping peers
            // Future: implement proper ping-pong with timeout
            renderPeerList();
        }

        // Get the status class for a peer
        function getPeerStatusClass(peerData) {
            if (peerData.inTopic) return 'connected';
            if (peerData.directConnected) return 'partial';
            return 'offline';
        }

        // Render the entire peer list from the peers Map
        function renderPeerList() {
            // Save the room item first
            const roomItem = peerList.querySelector('.peer-item.room');

            // Clear all non-room items
            const items = peerList.querySelectorAll('.peer-item:not(.room)');
            items.forEach(item => item.remove());

            // Clear peer selector options (except "My Files" option)
            const options = peerSelector.querySelectorAll('option:not([value="me"])');
            options.forEach(opt => opt.remove());

            // Sort peers: connected first, then partial, then offline
            const sortedPeers = [...peers.entries()].sort((a, b) => {
                const statusOrder = { connected: 0, partial: 1, offline: 2 };
                const aStatus = getPeerStatusClass(a[1]);
                const bStatus = getPeerStatusClass(b[1]);
                return statusOrder[aStatus] - statusOrder[bStatus];
            });

            // Render each peer
            for (const [peerID, data] of sortedPeers) {
                if (peerID === client.peerID) continue;

                const statusClass = getPeerStatusClass(data);
                const peerItem = document.createElement('div');
                peerItem.className = 'peer-item';
                peerItem.setAttribute('data-peer-id', peerID);

                // Create header with status dot and name
                const headerDiv = document.createElement('div');
                headerDiv.className = 'peer-header';

                const statusDot = document.createElement('span');
                statusDot.className = `status-dot ${statusClass}`;

                const nameDiv = document.createElement('div');
                nameDiv.className = 'peer-name';
                nameDiv.textContent = data.name || 'Peer';

                headerDiv.appendChild(statusDot);
                headerDiv.appendChild(nameDiv);

                const idDiv = document.createElement('div');
                idDiv.className = 'peer-id';
                idDiv.textContent = '...' + peerID.slice(-16);

                peerItem.appendChild(headerDiv);
                peerItem.appendChild(idDiv);

                peerItem.addEventListener('click', () => {
                    switchToDM(peerID);
                });

                peerList.appendChild(peerItem);

                // Add to peer selector
                const option = document.createElement('option');
                option.value = peerID;
                option.textContent = data.name || `Peer ...${peerID.slice(-8)}`;
                peerSelector.appendChild(option);

                // Update unread badge
                updateUnreadBadge(peerID);
            }

            // Re-apply active state if in DM mode
            if (currentMode === 'dm' && currentPeerID) {
                const activeItem = peerList.querySelector(`[data-peer-id="${currentPeerID}"]`);
                if (activeItem) {
                    activeItem.classList.add('active');
                }
            } else if (currentMode === 'room' && roomItem) {
                roomItem.classList.add('active');
            }
        }

        // Update a peer's topic status and re-render
        function setPeerInTopic(peerID, inTopic) {
            if (peerID === client.peerID) return;

            const existing = peers.get(peerID);
            if (existing) {
                existing.inTopic = inTopic;
                if (inTopic) existing.directConnected = true; // If in topic, must be connected
                peers.set(peerID, existing);
            } else if (inTopic) {
                // New peer from topic
                peers.set(peerID, {
                    name: `Peer ...${peerID.slice(-8)}`,
                    inTopic: true,
                    isContact: false,
                    directConnected: true
                });
            }
            renderPeerList();
        }

        // Handle peer leaving topic - only remove from list if not a contact
        function handlePeerLeftTopic(peerID) {
            const peerData = peers.get(peerID);
            if (peerData) {
                peerData.inTopic = false;
                peerData.directConnected = false; // Will be checked on next ping
                if (!peerData.isContact) {
                    // Not a contact, remove entirely
                    peers.delete(peerID);
                    // If we were DMing with this peer, switch back to room
                    if (currentMode === 'dm' && currentPeerID === peerID) {
                        updateMode('room');
                    }
                } else {
                    peers.set(peerID, peerData);
                }
            }
            renderPeerList();
        }

        // Legacy function names for compatibility
        function addPeerToList(peerID, name) {
            setPeerInTopic(peerID, true);
            // Update name if provided
            const peerData = peers.get(peerID);
            if (peerData && name) {
                peerData.name = name;
                peers.set(peerID, peerData);
            }
        }

        function removePeerFromList(peerID) {
            handlePeerLeftTopic(peerID);
        }

        function displayStoredMessages(peerID) {
            const messages = dmMessages.get(peerID);
            if (messages && messages.length > 0) {
                for (const msg of messages) {
                    addMessage(peerID, msg.text, msg.isOwn, false, true); // skipStorage = true
                }
            }
        }

        function displayStoredRoomMessages() {
            if (roomMessages.length > 0) {
                for (const msg of roomMessages) {
                    addMessage(msg.senderPeerID, msg.text, msg.isOwn);
                }
            }
        }

        function switchToDM(peerID) {
                updateMode('dm', peerID);
                clearUnreadCount(peerID);
                displayStoredMessages(peerID);
        }

        // File browser functions
        function updateSelectedFolderIndicator() {
            const isOwnFiles = currentFilePeerID === client.peerID;
            if (isOwnFiles && selectedFolder.get()) {
                selectedFolderIndicator.style.display = 'block';
                selectedFolderPath.textContent = '/' + selectedFolder.get();
            } else {
                selectedFolderIndicator.style.display = 'none';
            }
        }

        function buildFileTree(entries) {
            // Build hierarchical tree from flat pathname entries
            const tree = {};

            // Handle null/undefined entries
            if (!entries || typeof entries !== 'object') {
                console.warn('[File Browser] buildFileTree received invalid entries:', entries);
                return tree;
            }

            for (const [path, entry] of Object.entries(entries)) {
                // Skip empty paths
                if (!path || typeof path !== 'string') {
                    console.warn('[File Browser] Skipping invalid path:', path);
                    continue;
                }

                const parts = path.split('/');
                let current = tree;

                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    const isLast = i === parts.length - 1;

                    if (isLast) {
                        current[part] = { ...entry, path };
                    } else {
                        if (!current[part]) {
                            current[part] = { type: 'directory', children: {} };
                        }
                        current = current[part].children || (current[part].children = {});
                    }
                }
            }

            return tree;
        }

        function renderFileTree(tree, container, pathPrefix = '') {
            container.innerHTML = '';

            // Update selected folder indicator when rendering root
            if (pathPrefix === '' && container === fileTreeDiv) {
                updateSelectedFolderIndicator();
            }

            if (Object.keys(tree).length === 0) {
                container.innerHTML = '<div style="padding: 1rem; text-align: center; color: #999;">No files</div>';
                return;
            }

            const sortedEntries = Object.entries(tree).sort(([a], [b]) => {
                // Directories first, then files
                const aIsDir = tree[a].type === 'directory';
                const bIsDir = tree[b].type === 'directory';
                if (aIsDir && !bIsDir) return -1;
                if (!aIsDir && bIsDir) return 1;
                return a.localeCompare(b);
            });

            for (const [name, entry] of sortedEntries) {
                const itemPath = pathPrefix ? `${pathPrefix}/${name}` : name;
                const itemDiv = document.createElement('div');
                itemDiv.className = 'file-tree-item' + (entry.type === 'directory' ? ' directory' : '');

                // Create header div to hold the item's content
                const headerDiv = document.createElement('div');
                headerDiv.className = 'file-tree-item-header';

                if (entry.type === 'directory') {
                    const isExpanded = expandedDirs.has(itemPath);
                    const isSelected = selectedFolder.get() === itemPath;
                    itemDiv.classList.toggle('collapsed', !isExpanded);
                    itemDiv.classList.toggle('selected', isSelected);

                    // Click folder to toggle selection
                    headerDiv.onclick = (e) => {
                        // Don't select if clicking expand icon
                        if (e.target.classList.contains('expand-icon')) {
                            return;
                        }
                        // Toggle selection: if already selected, deselect; otherwise select
                        if (selectedFolder.get() === itemPath) {
                            selectedFolder.set('');
                        } else {
                            selectedFolder.set(itemPath);
                        }
                        renderFileTree(currentFileEntries, fileTreeDiv);
                    };

                    const expandIcon = document.createElement('span');
                    expandIcon.className = 'expand-icon';
                    expandIcon.textContent = isExpanded ? 'â–¼' : 'â–¶';
                    expandIcon.onclick = (e) => {
                        e.stopPropagation();
                        if (expandedDirs.has(itemPath)) {
                            expandedDirs.delete(itemPath);
                        } else {
                            expandedDirs.add(itemPath);
                        }
                        renderFileTree(currentFileEntries, fileTreeDiv);
                    };
                    headerDiv.appendChild(expandIcon);
                }

                const icon = document.createElement('span');
                icon.className = 'icon';
                icon.textContent = entry.type === 'directory' ? 'ðŸ“' : 'ðŸ“„';
                headerDiv.appendChild(icon);

                const nameSpan = document.createElement('span');
                nameSpan.className = 'name';
                nameSpan.textContent = name;
                headerDiv.appendChild(nameSpan);

                if (entry.cid) {
                    const cidSpan = document.createElement('span');
                    cidSpan.className = 'cid';
                    cidSpan.textContent = '...' + entry.cid.slice(-12);
                    headerDiv.appendChild(cidSpan);

                    // Add action buttons
                    const actions = document.createElement('div');
                    actions.className = 'actions';

                    // Add download button for files
                    if (entry.type === 'file') {
                        const downloadBtn = document.createElement('button');
                        downloadBtn.className = 'action-btn';
                        downloadBtn.textContent = 'Download';
                        downloadBtn.onclick = (e) => {
                            e.stopPropagation();
                            // Use fallback peer if viewing remote peer's files
                            const fallbackPeer = (currentFilePeerID && currentFilePeerID !== client.peerID) ? currentFilePeerID : undefined;
                            downloadFile(entry.cid, name, fallbackPeer, downloadBtn);
                        };
                        actions.appendChild(downloadBtn);
                    }

                    // Add delete button for own files/directories only
                    const isOwnFiles = !currentFilePeerID || currentFilePeerID === client.peerID;
                    if (isOwnFiles) {
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'action-btn delete-btn';
                        deleteBtn.textContent = 'Delete';
                        deleteBtn.onclick = async (e) => {
                            e.stopPropagation();
                            const itemType = entry.type === 'directory' ? 'folder' : 'file';
                            if (confirm(`Delete ${itemType} "${name}"?`)) {
                                try {
                                    await client.removeFile(itemPath);
                                    // Refresh file list
                                    loadPeerFiles(currentFilePeerID || client.peerID);
                                } catch (err) {
                                    alert(`Failed to delete: ${err.message}`);
                                }
                            }
                        };
                        actions.appendChild(deleteBtn);
                    }

                    if (actions.children.length > 0) {
                        headerDiv.appendChild(actions);
                    }
                }

                itemDiv.appendChild(headerDiv);

                // Render children if directory and expanded
                if (entry.type === 'directory' && entry.children) {
                    const childrenDiv = document.createElement('div');
                    childrenDiv.className = 'file-tree-children';
                    renderFileTree(entry.children, childrenDiv, itemPath);
                    itemDiv.appendChild(childrenDiv);
                }

                container.appendChild(itemDiv);
            }
        }

        async function loadPeerFiles(peerID) {
            // Only reset selection when actually switching to a different peer (not on initial load)
            if (currentFilePeerID !== null && currentFilePeerID !== peerID) {
                selectedFolder.set('');
            }
            currentFilePeerID = peerID;
            fileTreeDiv.innerHTML = '<div style="padding: 1rem; text-align: center; color: #999;">Loading...</div>';

            try {
                console.log('[File Browser] Loading files for peer:', peerID);
                const result = await client.listFiles(peerID);
                console.log('[File Browser] Received file list:', result);

                // Check if result is valid
                if (!result || typeof result !== 'object') {
                    throw new Error('Invalid result from listFiles: ' + JSON.stringify(result));
                }

                // Handle empty or missing entries
                const entries = result.entries || {};
                console.log('[File Browser] Processing', Object.keys(entries).length, 'entries');

                currentFileEntries = buildFileTree(entries);
                renderFileTree(currentFileEntries, fileTreeDiv);

                // Update UI based on whether viewing own files
                const isOwnFiles = peerID === client.peerID;
                uploadFileBtn.disabled = !isOwnFiles;
                createDirBtn.disabled = !isOwnFiles;
                uploadFileBtn.textContent = isOwnFiles ? 'Upload File' : 'ðŸš« Upload File';
                createDirBtn.textContent = isOwnFiles ? 'New Folder' : 'ðŸš« New Folder';
                dropZone.classList.toggle('hidden', !isOwnFiles);
            } catch (error) {
                console.error('[File Browser] Failed to load files:', error);
                fileTreeDiv.innerHTML = '<div style="padding: 1rem; text-align: center; color: #e74c3c;">Failed to load files: ' + error.message + '</div>';
            }
        }

        async function downloadFile(cid, filename, fallbackPeerID, downloadBtn) {
            // Show spinner on the download button
            if (downloadBtn) {
                downloadBtn.classList.add('downloading');
                downloadBtn.textContent = 'Downloading...';
                downloadBtn.disabled = true;
            }

            try {
                const content = await client.getFile(cid, fallbackPeerID);

                if (content.type === 'file') {
                    // Decode base64 content and trigger download
                    const binaryString = atob(content.content);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }

                    const blob = new Blob([bytes], { type: content.mimeType || 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(url);
                } else {
                    alert('Cannot download directory');
                }
            } catch (error) {
                console.error('Failed to download file:', error);
                alert('Failed to download file');
            } finally {
                // Hide spinner and restore button
                if (downloadBtn) {
                    downloadBtn.classList.remove('downloading');
                    downloadBtn.textContent = 'Download';
                    downloadBtn.disabled = false;
                }
            }
        }

        async function uploadFiles(files) {
            // Show loading indicator
            fileTreeDiv.innerHTML = '<div style="padding: 1rem; text-align: center; color: #3498db;">Uploading ' + files.length + ' file(s)...</div>';

            let successCount = 0;
            let failCount = 0;

            for (const file of files) {
                try {
                    const content = await file.arrayBuffer();
                    const uint8Array = new Uint8Array(content);
                    // Prefix with selected folder path
                    const filePath = selectedFolder.get() ? `${selectedFolder.get()}/${file.name}` : file.name;
                    await client.storeFile(filePath, uint8Array);
                    successCount++;
                } catch (error) {
                    console.error(`Failed to upload ${file.name}:`, error);
                    failCount++;
                }
            }

            // Expand the selected folder so uploaded files are visible
            if (selectedFolder.get()) {
                expandedDirs.add(selectedFolder.get());
            }

            // Show brief success/error message before reloading
            if (failCount === 0) {
                fileTreeDiv.innerHTML = '<div style="padding: 1rem; text-align: center; color: #27ae60;">âœ“ Uploaded ' + successCount + ' file(s) successfully</div>';
            } else {
                fileTreeDiv.innerHTML = '<div style="padding: 1rem; text-align: center; color: #e74c3c;">âš  Uploaded ' + successCount + ' file(s), ' + failCount + ' failed</div>';
            }

            // Wait a moment before reloading to let user see the message
            await new Promise(resolve => setTimeout(resolve, 500));

            // Reload file list
            await loadPeerFiles(client.peerID);
        }

        async function createDirectory() {
            const dirName = prompt('Enter directory name:');
            if (!dirName) return;

            try {
                // Prefix with selected folder path
                const dirPath = selectedFolder.get() ? `${selectedFolder.get()}/${dirName}` : dirName;
                await client.createDirectory(dirPath);

                // Expand the newly created directory
                expandedDirs.add(dirPath);

                // Set the selection BEFORE reloading so loadPeerFiles sees it
                selectedFolder.set(dirPath);

                // Reload the file list (this will render with the selection)
                await loadPeerFiles(client.peerID);
            } catch (error) {
                console.error('Failed to create directory:', error);
                alert('Failed to create directory');
            }
        }

        // File browser event handlers
        browseFilesBtn.addEventListener('click', () => {
            fileBrowserModal.classList.add('active');
            const peerID = currentMode === 'dm' ? currentPeerID : client.peerID;
            peerSelector.value = peerID === client.peerID ? 'me' : peerID;
            loadPeerFiles(peerID);
        });

        modalCloseBtn.addEventListener('click', () => {
            fileBrowserModal.classList.remove('active');
        });

        peerSelector.addEventListener('change', (e) => {
            const value = e.target.value;
            const peerID = value === 'me' ? client.peerID : value;
            loadPeerFiles(peerID);
        });

        uploadFileBtn.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                uploadFiles(Array.from(e.target.files));
                e.target.value = ''; // Reset input
            }
        });

        createDirBtn.addEventListener('click', createDirectory);

        // Drag and drop support
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');

            const files = Array.from(e.dataTransfer.files);
            uploadFiles(files);
        });

        // Contacts event handlers
        // Spec: main.md (demo contact list)
        contactsBtn.addEventListener('click', () => {
            // Open modal and populate from current contacts
            modalContacts = new Set(currentContacts);
            renderContactsList();
            contactsModal.classList.add('active');
            contactInput.value = '';
        });

        contactsCloseBtn.addEventListener('click', () => {
            contactsModal.classList.remove('active');
        });

        contactsCancelBtn.addEventListener('click', () => {
            contactsModal.classList.remove('active');
        });

        contactsAcceptBtn.addEventListener('click', async () => {
            // Compute diff between modalContacts and currentContacts
            const added = [...modalContacts].filter(id => !currentContacts.has(id));
            const removed = [...currentContacts].filter(id => !modalContacts.has(id));

            try {
                // Call API methods
                if (added.length > 0) {
                    await client.addPeers(added);
                }
                if (removed.length > 0) {
                    await client.removePeers(removed);
                }

                // Update session state
                currentContacts = new Set(modalContacts);

                // Update peers Map with contact status
                for (const peerID of added) {
                    const existing = peers.get(peerID);
                    if (existing) {
                        existing.isContact = true;
                        peers.set(peerID, existing);
                    } else {
                        // New contact not in topic - add to peers and check connection
                        peers.set(peerID, {
                            name: `Peer ...${peerID.slice(-8)}`,
                            inTopic: false,
                            isContact: true,
                            directConnected: false // Will be checked
                        });
                    }
                }

                // Mark removed contacts as not contacts
                for (const peerID of removed) {
                    const existing = peers.get(peerID);
                    if (existing) {
                        existing.isContact = false;
                        // If not in topic and not a contact, remove entirely
                        if (!existing.inTopic) {
                            peers.delete(peerID);
                        } else {
                            peers.set(peerID, existing);
                        }
                    }
                }

                contactsModal.classList.remove('active');

                // Re-render and check connections for new contacts
                renderPeerList();
                if (added.length > 0) {
                    refreshContactConnections();
                }
            } catch (error) {
                console.error('Error updating contacts:', error);
                alert('Failed to update contacts: ' + error.message);
            }
        });

        addContactBtn.addEventListener('click', () => {
            const peerID = contactInput.value.trim();
            if (!peerID) return;

            // Basic validation: check if it looks like a peer ID
            if (peerID.length < 10) {
                alert('Invalid peer ID format');
                return;
            }

            // Check for duplicates
            if (modalContacts.has(peerID)) {
                alert('Peer ID already in contact list');
                return;
            }

            // Add to modal contacts
            modalContacts.add(peerID);
            contactInput.value = '';
            renderContactsList();
        });

        contactInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                addContactBtn.click();
            }
        });

        function renderContactsList() {
            if (modalContacts.size === 0) {
                contactsList.innerHTML = '<div class="empty-contacts">No contacts yet. Add peer IDs above to protect their connections.</div>';
                return;
            }

            const contactsArray = [...modalContacts].sort();
            contactsList.innerHTML = contactsArray.map(peerID => `
                <div class="contact-item">
                    <div class="peer-id">${peerID}</div>
                    <button class="remove-btn" data-peer-id="${peerID}">&times;</button>
                </div>
            `).join('');

            // Add remove button listeners
            contactsList.querySelectorAll('.remove-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const peerID = btn.dataset.peerId;
                    modalContacts.delete(peerID);
                    renderContactsList();
                });
            });
        }

        async function sendMessage() {
            const text = messageInput.value.trim();
            if (!text) return;

            try {
                if (currentMode === 'room') {
                    await client.publish(ROOM_TOPIC, { text });
                    storeRoomMessage(client.peerID, text, true);
                    addMessage(client.peerID, text, true);
                } else if (currentMode === 'dm' && currentPeerID) {
                    await client.send(currentPeerID, PROTOCOL, { text });
                    storeDMMessage(currentPeerID, text, true);
                    addMessage(client.peerID, text, true, false, true); // skipStorage = true (already stored)
                }
                messageInput.value = '';
            } catch (error) {
                console.error('Failed to send message:', error);
                setStatus('Failed to send message', 'error');
            }
        }

        // Room chat button handler
        document.querySelector('.peer-item.room').addEventListener('click', async () => {
            updateMode('room');
        });

        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // Initialize
        (async () => {
            try {
                // Connect and initialize the client
                client = await connect({
                    onClose: () => setStatus('Disconnected', 'error')
                });
                console.log(`p2p-webapp version: ${client.version}`);

                peerIDDiv.textContent = `Your Peer ID: ${client.peerID}`;
                setStatus('Connecting to network...', 'connecting');

                // Start protocol with listener for direct messages
                // The listener receives (peer, data) for all messages on this protocol
                await client.start(PROTOCOL, (peer, data) => {
                    // Always store the message
                    storeDMMessage(peer, data.text, false);
                    // Only display if currently viewing this DM
                    if (currentMode === 'dm' && currentPeerID === peer) {
                        addMessage(peer, data.text, false);
                    } else {
                        // Increment unread count if not currently viewing this peer's DM
                        incrementUnreadCount(peer);
                    }
                });

                // Subscribe to room chat with peer change monitoring
                await client.subscribe(
                    ROOM_TOPIC,
                    // Message callback
                    (senderPeerID, data) => {
                        // Handle file update notifications
                        if (data.type === 'p2p-webapp-file-update' && data.peer) {
                            // If we're currently viewing this peer's files in the file browser, refresh the file list
                            if (currentFilePeerID === data.peer && fileBrowserModal.classList.contains('active')) {
                                loadPeerFiles(data.peer).catch(err => {
                                    console.error('Error refreshing file list:', err);
                                });
                            }
                            return; // Don't process as a chat message
                        }

                        if (senderPeerID !== client.peerID) {
                            // Always store room messages
                            storeRoomMessage(senderPeerID, data.text, false);
                            // Only display if currently in room mode
                            if (currentMode === 'room') {
                                addMessage(senderPeerID, data.text, false);
                            } else {
                                // Increment unread count when not viewing room
                                incrementRoomUnreadCount();
                            }
                        }
                    },
                    // Peer change callback (joined: boolean)
                    (peerID, joined) => {
                        if (peerID === client.peerID) return; // Skip ourselves

                        if (joined) {
                            addPeerToList(peerID, `Peer ...${peerID.slice(-8)}`);
                        } else {
                            removePeerFromList(peerID);
                        }
                    }
                );

                // Now connected to pubsub group - show connected status
                setStatus('Connected', 'connected');

                // Get initial peer list
                try {
                    const peerIDs = await client.listPeers(ROOM_TOPIC);
                    for (const peerID of peerIDs) {
                        if (peerID !== client.peerID) {
                            addPeerToList(peerID, `Peer ...${peerID.slice(-8)}`);
                        }
                    }
                } catch (error) {
                    console.error('Failed to get initial peer list:', error);
                }

                // Start periodic ping check for contacts (every 30 seconds)
                pingCheckInterval = setInterval(() => {
                    refreshContactConnections();
                }, 30000);

                messageInput.disabled = false;
                sendButton.disabled = false;
                browseFilesBtn.disabled = false;
                contactsBtn.disabled = false;
                messageInput.focus();

                addMessage('', 'Welcome to the P2P chatroom! Your messages are distributed peer-to-peer.', false, true);
            } catch (error) {
                console.error('Initialization error:', error);
                setStatus('Failed to connect', 'error');
            }
        })();
    </script>
</body>
</html>
